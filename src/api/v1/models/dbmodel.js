import db from '../../db';
import {
  genAndClause,
  joinColumns,
  genInsertValuesClause,
  buildValuesArray,
  genSetClause,
} from '../../utils/modelUtils';

export default class DBModel {
  // TO-DO: data validation on save

  //= =================================================================>
  // OVERWRITE THESE IN CHILDREN
  //= ==================================================================>
  // primary key field
  static pkfield() { return 'pk'; }

  // prejoin in db as view for lookup fields
  static viewTable() { return 'test'; }

  // table meant to write to
  static modifyTable() { return 'test'; }

  // fields to be written to
  static modifyFields() { return ['col1', 'col2']; }
  //= ===================================================================>


  //= =======================================================================>
  // GET SINGLE RECORD BY ID
  //= =======================================================================>

  static async getbyId(id, returnCols = []) {
    // query db by id

    // check if optional return columns are specified
    // otherwise return all (*)
    const selCols = returnCols.length === 0 ? '*' : joinColumns(returnCols);

    // build query string to return one record matching pk field
    const queryString = `
            select ${selCols} 
            from ${this.viewTable()} 
            where ${this.pkfield()} = ${id} limit 1`;

    // run query
    const result = await db.query(queryString);

    if (!result.rowCount) throw new Error(`${this.name} not found`);

    // create new instance of class
    const newModel = new this();

    // assign properties from DB record and return
    const res = Object.assign(newModel, result.rows[0]);

    return res;
  }
  //= ==================================================================>


  //= ==================================================================>
  // GET SEVERAL RECORDS WITH CUSTOM OUTPUT
  //= ==================================================================>

  static async getAll(whereObject = {}, returnCols = [], orderbyArray = []) {
    // query db with flexible query

    let whereClause = '';

    // check if whereclause object specified
    // if specified build where clause using key/pair separated by AND
    if (Object.keys(whereObject).length) {
      whereClause = `where ${genAndClause(whereObject)}`;
    }

    // if no order by specified, order by PK field
    let orderClause = `${this.pkfield()} asc`;

    // if specified join various order-by phrases with commas
    if (orderbyArray.length) {
      orderClause = joinColumns(orderbyArray);
    }

    // check if optional return columns are specified
    // otherwise return all (*)
    const selCols = returnCols.length === 0 ? '*' : joinColumns(returnCols);

    // build select query string
    const queryString = `
            select ${selCols} 
            from ${this.viewTable()} ${whereClause} 
            order by ${orderClause};
        `;

    // run query
    const result = await db.query(queryString);

    if (!result.rowCount) throw new Error(`${this.name} not found`);

    return result.rows;
  }
  //= ====================================================================>


  //= ==================================================================>
  // SAVE AS INSERT FOR NEW RECORDS OR UPDATE FOR EXISTING RECORDS
  //= ==================================================================>

  async save() {
    // if(this.constructor.readOnly) {
    //   throw new Error(`attempting to modify read-only model - ${this.constructor.name}`);
    // }

    if (this[this.constructor.pkfield()] <= 0) {
      // an insert
      // generate Insert fields clause
      const insertFields = joinColumns(this.constructor.modifyFields());

      // build insert query string
      const queryString = `
                insert into ${this.constructor.modifyTable()} (${insertFields})
                values (${genInsertValuesClause(this.constructor.modifyFields())}) 
                returning * ;
            `;
      // run insert query
      //console.log(queryString);
      const result = await db.query(
        queryString,
        buildValuesArray(this, this.constructor.modifyFields()),
      );

      // update pkfield and other fields to new autogenerated value     
      const id = result.rows[0][this.constructor.pkfield()];
      
      const updatedObj = await this.constructor.getbyId(id);
      Object.assign(this, updatedObj);

      // this[this.constructor.pkfield()] = result.rows[0][this.constructor.pkfield()];
    } else {
      // this is an update cos pk field has value

      // build update query string speciying pk field matching record
      const queryString = `
                update ${this.constructor.modifyTable()} 
                set ${genSetClause(this.constructor.modifyFields())}                    
                where ${this.constructor.pkfield()} = ${this[this.constructor.pkfield()]}
                returning * ;
            `;

      // run update query returning updated values
      const result = await db.query(
        queryString,
        buildValuesArray(this, this.constructor.modifyFields()),
      );

      const id = result.rows[0][this.constructor.pkfield()];
      const updatedObj = await this.constructor.getbyId(id);
      Object.assign(this, updatedObj);
      // Object.assign(this, result.rows[0]);
    }
  }

  //= =========================================================================>


  //= =========================================================================>
  // DELETE THIS RECORD
  //= ==========================================================================>

  async deleteOne() {
    // throw error if read-only model
    // if(this.constructor.readOnly) {
    //   throw new Error(`attempting to modify read-only model - ${this.constructor.name}`);
    // }

    // build query string to delete record
    const queryString = `
            delete from ${this.constructor.modifyTable()} 
            where ${this.constructor.pkfield()} = $1;
        `;

    // run delete query
    await db.query(queryString, [this[this.constructor.pkfield()]]);


    // empty object fields
    Object.keys(this).forEach((key) => { delete this[key]; });
  }

  //= =====================================================================>
}
